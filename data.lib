###############################################################
#
#   Program Data Library
#
################################################################

# ghostAPT Codex
# Table of Contents
# 1. Core Data
# 2. ghostAPT Functions
# 3. Terminal Menus

###############################################################
#
#   1. Core Data
#
################################################################

# Program development credits
credits (){

echo "Developer(s):-JCore92
--
Website:-https://www.jcorestudios.com/
-https://github.com/jcore92/ghostAPT
--
License:-Open Source/Freeware (If forked, please give
-credit to the original project/developer. If
-no credit is included you are not allowed to
-use any original names or likeness.)
--
Notes:-Built for Kubuntu Focus 24.04 LTS.
-*Compatible with any Ubuntu based KDE distros.
--
Disclaimer:-We hold no liability for any negative outcomes
-to you or your devices. ALWAYS READ SCRIPTS
-BEFORE YOU RUN THEM!
--
-By proceeding, you agree to these terms.
--
--" | column -t -s '-' | fold -w $terminalwidth | center

}

# Dependency request
installerwarning (){

jcore92credits

echo "WARNING!
" | center

echo "       âš ï¸
" | center

echo "$programname is currently still being developed and is in BETA and may show    signs of incompleteness or may have minor bugs. Please use this script in a virtual machine until you are familiar with how it operates. Use this     program and its 'Ghost Scripts' responsibly as scripts enable PERMANENT    changes to your Linux installation.

" | fold -w $terminalwidth | center

}

systeminfo () {

mkdir $localtempdirectory &>/dev/null

systeminfotempfile="$localtempdirectory/systeminfo"

osprobe="Operating System:
$(grep -E '^(PRETTY_NAME)=' /etc/os-release | awk -F "NAME=" '{ gsub ("\"", "") } {print$2}') with $(echo $XDG_CURRENT_DESKTOP) on a $(echo $XDG_SESSION_TYPE) session"

ramprobe="System RAM:
$(free -h | grep 'Mem' | awk '{print$2}')"

processorprobe="Processor:
$(lscpu | grep 'Model name' | cut -f 2 -d ":" | awk '{$1=$1}1') - $(uname -m)"

gpuprobe="Graphics:
$(lspci | grep 'VGA compatible controller' | awk -F ':' '{sub(/^ */,"",$3); print $3}')"

localipprobe="Local IP:
$(hostname -I | head -n '1' | awk -F " " '{print $1}')"

copyallsyscol="
ðŸ“‹ Copy All System Information to clipboard
 "

hidepublicipprobe

options=("$osprobe" "$ramprobe" "$processorprobe" "$gpuprobe" "$localipprobe" "$publicipprobe" "$copyallsyscol")

}

sysinfo-os () {
# Operating System
echo "$osprobe" | tee $systeminfotempfile; xclip -selection clipboard < $systeminfotempfile
rm -fr $systeminfotempfile
}

sysinfo-ram () {
# Sytem Ram
echo "$ramprobe" | tee $systeminfotempfile; xclip -selection clipboard < $systeminfotempfile
rm -fr $systeminfotempfile
}

sysinfo-processor () {
# Processor
echo "$processorprobe" | tee $systeminfotempfile; xclip -selection clipboard < $systeminfotempfile
rm -fr $systeminfotempfile
}

sysinfo-graphics () {
# Graphics
echo "$gpuprobe" | tee $systeminfotempfile; xclip -selection clipboard < $systeminfotempfile
rm -fr $systeminfotempfile
}

hidepublicipprobe () {
publicipprobe="Public IP:
***.***.***.***"
}

showpublicipprobe () {
publicipprobe="Public IP:
$(dig +short myip.opendns.com @resolver1.opendns.com)"
}

sysinfo-localip () {
# Local IP
echo "$localipprobe" | tee $systeminfotempfile; xclip -selection clipboard < $systeminfotempfile
rm -fr $systeminfotempfile
}

sysinfo-publicip () {
# Public IP
showpublicipprobe
echo "$publicipprobe" | tee $systeminfotempfile; xclip -selection clipboard < $systeminfotempfile
rm -fr $systeminfotempfile
}

sysinfo-copyall () {
# ** Copy All System Information to clipboard **
echo "
$osprobe

$ramprobe

$processorprobe

$gpuprobe

$localipprobe

$publicipprobe
" | tee $systeminfotempfile; xclip -selection clipboard < $systeminfotempfile

rm -fr $systeminfotempfile
}

sysinfo-all () {
showpublicipprobe
# ** Show All System Information **
echo "
$osprobe

$ramprobe

$processorprobe

$gpuprobe

$localipprobe

$publicipprobe
"
}

installationstatus (){

isproginstalled="$(ls $HOME | grep -o "ghostAPT" | head -n 1)"


if [ -d "$localinstalldirectory" ]; then
whichverinstalled="$(grep "version" $localinstalldirectory/ghostAPT.sh | awk -F '"' '{print$2}')"
fi

prebeta20fix="$HOME/GhostAPT"
if [ -d "$prebeta20fix" ]; then
whichverinstalled="$(grep "version" $prebeta20fix/ghostAPT.sh | awk -F '"' '{print$2}')"
fi



if [ "$isproginstalled" != ghostAPT ]; then installationstatus="Uninstalled"
else
installationstatus="$whichverinstalled is Installed"
fi



if [ "$needsupdates" == 0 ]; then
installationstatus="Up to date."
fi



if [ "$needsupdates" == 1 ]; then

installationstatus="DEPRECATED"

echo "Installation Status: $installationstatus, $remote_version $remote_beta_status available!
" | center

else

echo "Installation Status: $installationstatus
" | center

fi

}

createprogshortcuts (){

echo "#!/usr/bin/env xdg-open
[Desktop Entry]
Version=1.0
Name=ghostAPT
GenericName=ghostAPT

Exec=konsole -e \"/usr/local/bin/ghostAPT run\"
StartupNotify=true
Terminal=false
Icon=/usr/share/icons/ghostAPT/ghost.png
Type=Application
Categories=Utilities;
Actions=ghostAPT;manage-installion;

[Desktop Action ghostAPT]
Name=Run ghostAPT
Exec=konsole -e \"/usr/local/bin/ghostAPT run\"

[Desktop Action manage-installion]
Name=Manage ghostAPT Installation
Exec=konsole -e \"/usr/local/bin/ghostAPT install\"" | tee $HOME/Desktop/"$programname" ; chmod u+x $HOME/Desktop/"$programname" ; sudo cp -fv $HOME/Desktop/"$programname" /usr/share/applications/"$programname.desktop"

}

repositorylist (){

    echo "Downloading The Ghost Team Script Collection (Repository)..."

    curl -L -o "$localinstalldirectory/Get Ghost Scripts/The Ghost Team Script Collection (Repository).ghost" "https://github.com/jcore92/The-Ghost-Team-Script-Collection/raw/refs/heads/main/Get%20Ghost%20Scripts/The%20Ghost%20Team%20Script%20Collection%20(Repository).ghost"

    echo "Downloading JCore92 Script Collection (Repository)..."

    curl -L -o "$localinstalldirectory/Get Ghost Scripts/JCore92 Script Collection (Repository).ghost" "https://github.com/jcore92/JCore92-Script-Collection/raw/refs/heads/main/Get%20Ghost%20Scripts/JCore92%20Script%20Collection%20(Repository).ghost"

}

refreshrepositories (){

    # Cleanup function: accepts a file path and removes it if it exists
    cleanup_old_file() {
        local filepath="$1"

        if [ -f "$filepath" ]; then
            echo "Removing old file: $filepath"
            rm -rfv "$filepath"
        fi
    }

    # List of old repository files to clean up (during update)
    OLD_SCRIPTS=(
        "$localinstalldirectory/Get Ghost Scripts/The Ghost Team Script Collection - Repository.ghost"
        "$localinstalldirectory/Get Ghost Scripts/JCore92 Script Collection - Repository.ghost"
        # Add more legacy filenames here as needed
    )

    # Run cleanup for each file
    for oldfile in "${OLD_SCRIPTS[@]}"; do
        cleanup_old_file "$oldfile"
    done

    repositorylist

}

installation (){

    libraryhandlerinstaller (){
    findlibrarycurrentdirectory="$(ls ./ | grep -o "$libraryname" | head -n 1)"

    if [ "$findlibrarycurrentdirectory" == $libraryname ]; then
    echo "
    $libraryname found in current directory. Copying to install directory...
    "

    cp -v ./$libraryname $localinstalldirectory
    else

    echo "
$libraryname not found in current directory...
    "
    findtemplibrary="$(ls $localtempdirectory | grep -o "$libraryname" | head -n 1)"

    if [ "$findtemplibrary" == $libraryname ]; then
    echo "$libraryname found in $localtempdirectory, Moving to install directory...
    "

    mv -v $localtempdirectory/$libraryname $localinstalldirectory

    else
    echo "$libraryname not found in $localtempdirectory, downloading...
    "
    sleep 1
    curl -L -o $localinstalldirectory/$libraryname $remotelibrarylink

    fi
    fi
    }

    echo "
Starting Installation...
    "

    # Shared Dynamic Variables for Libraries



    mkdir $localinstalldirectory &>/dev/null

    # Independent Dynamic Variables for Libraries

    libraryname="ghostAPT.sh"

    remotelibrarylink="https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/ghostAPT.sh"

    libraryhandlerinstaller

    libraryname="interface.lib"

    remotelibrarylink="https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/interface.lib"

    libraryhandlerinstaller

    libraryname="data.lib"

    remotelibrarylink="https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/data.lib"

    libraryhandlerinstaller

    # Install Start Menu & Desktop Icons

    libraryname="ghost.png"

    remotelibrarylink="https://raw.githubusercontent.com/jcore92/ghostAPT/c7f986707449cc77f2ac6384aa30aaa3b5c96c07/ghost.png"

    libraryhandlerinstaller

    #echo "
#Please type your password and press enter:
#"

    sudo mkdir /usr/share/icons/ghostAPT
    sudo mv "$localinstalldirectory/ghost.png" "/usr/share/icons/ghostAPT/ghost.png"

    createprogshortcuts

    # ghostAPT Script Updater Installer
    sudo apt-get update

    sudo apt-get install -y curl wget jq 7zip xdotool zenity pv

    mkdir "$localinstalldirectory/Get Ghost Scripts" &>/dev/null

    repositorylist

    # Clean temp folder
    echo "
    "
    rm -rfv $localtempdirectory

    sudo ln -s -v $localinstalldirectory/ghostAPT.sh /usr/local/bin/ghostAPT

    signatureupdate-force

    echo "
Installation is complete. $programname will exit, please restart $programname with the new shortcuts made."

    entertocontinue

    hierarchy="0"

    clear

}

uninstaller (){

    sudo rm -rfv "/usr/local/bin/ghostAPT" "$localinstalldirectory" "$localtempdirectory" "$HOME/Desktop/$programname" "/usr/share/applications/$programname.desktop" "/usr/share/icons/ghostAPT"

    echo "
    Uninstall has complete.
    "

    entertocontinue

    hierarchy="0"

    clear

}

basic_cursor_menu() {
    local prompt="$1" outvar="$2" options=("${@:3}")
    local cur=0 count=${#options[@]}
    local esc=$(echo -en "\e")

    printf "$prompt\n"
    while true; do
        local index=0
        for o in "${options[@]}"; do
            if [ $index -eq $cur ]; then
                echo -e " >\e[7m$o\e[0m"
            else
                echo "  $o"
            fi
            ((index++))
        done

        read -s -n3 key
        case "$key" in
            "$esc[A") ((cur--)); ((cur < 0)) && cur=0 ;;
            "$esc[B") ((cur++)); ((cur >= count)) && cur=$((count - 1)) ;;
            "") break ;;
        esac
        echo -en "\e[${count}A"
    done

    printf -v "$outvar" "${options[$cur]}"
}

###############################################################
#
#   2. ghostAPT Functions
#
###############################################################
trustinstalledscripts() {
    # Define the signature ID
    signatureid="$USER"

    # Function to process files
    process_file() {
        local file="$1"
        local base_name=$(basename "${file%.ghost}")

        # Generate the SHA-256 checksum for the file
        checksum=$(sha256sum "$file" | cut -d ' ' -f1)

        # Output the signature, base name, and checksum to the master file using tee -a
        echo "SHA-256 checksum(s) found:
$checksum
$base_name
"
        echo "$checksum $signatureid (${base_name})" >> "$localinstalldirectory/ghostAPT_signatures.sha256"
    }

    # Find all .ghost files recursively in the $localinstalldirectory directory
    if [ -d "$localinstalldirectory" ]; then
        find -L "$localinstalldirectory" -type f -name "*.ghost" | while read -r file; do
            process_file "$file"
        done

        # Output the SHA-256 checksums for all .ghost files recursively
        #echo "
#exporting sha256sum for all .ghost files recursively:"
        #find -L "$localinstalldirectory" -type f -name "*.ghost" -exec sha256sum {} \;

        # Generate the SHA-256 hash of the ghostAPT_signatures.sha256 file to implement redundancy
        #sha256sum "$localinstalldirectory/ghostAPT_signatures.sha256" | cut -d ' ' -f1 ; > "$localinstalldirectory/key.sha256"
entertocontinue | center
        # Check if the key.sha256 file was successfully created
        if [ -f "$localinstalldirectory/key.sha256" ]; then
            echo "SHA-256 signature successfully created: $localinstalldirectory/key.sha256"
        else
            echo "Error: Failed to create SHA-256 signature."
            exit 1
        fi
    else
        echo "Error: Specified directory does not exist."
        exit 1
    fi
}

signature() {
  # Get the name of the currently running script
  script_name=$(basename "$0" .ghost)

  scrapecurrentdir="$(readlink -f "$0")"

  # Calculate the current checksum of the script using SHA-256
  current_checksum=$(sha256sum "$scrapecurrentdir" | cut -d ' ' -f1)

  echo "Signature:
$current_checksum"

  # Extract the line containing the current checksum (only the first match)
  signature_line=$(grep "$current_checksum" "$localinstalldirectory/ghostAPT_signatures.sha256" | head -n 1)

  if [ -z "$signature_line" ]; then
    author_checksum="UNKNOWN"
    scriptname_checksum="UNKNOWN"
    echo "Script Name: $scriptname_checksum"
    echo "Signed By: $author_checksum"
    echo "
                This script is UNSIGNED and may not be safe to run!
                (Maybe you modified the original script or perhaps
                you added an UNTRUSTED author's script/repository?)" | print_red #| center
    entertocontinue
    return
  fi

  # Extract the author and script name from the signature line
  stored_checksum=$(echo "$signature_line" | cut -d ' ' -f1)
  author_checksum=$(echo "$signature_line" | cut -d ' ' -f2- | awk -F '[' '{print $1}')
  scriptname_checksum=$(echo "$signature_line" | cut -d '[' -f2 | cut -d ']' -f1)

  # Handle cases where the author or script name is not found
  if [ -z "$author_checksum" ]; then
    author_checksum="UNKNOWN"
  fi

  if [ -z "$scriptname_checksum" ]; then
    scriptname_checksum="UNKNOWN"
  fi

  if [ "$author_checksum" == "$stored_checksum" ]; then
    author_checksum="UNKNOWN"
  fi

  if [ "$scriptname_checksum" == "$stored_checksum" ]; then
    scriptname_checksum="UNKNOWN"
  fi

  echo "Script Name: $scriptname_checksum"
  echo "Signed By: $author_checksum"

  # Verify the checksum
  if [ "$current_checksum" == "$stored_checksum" ]; then
    echo "
This script is SIGNED and is trusted by it's signature."
    sleep 2
  else
    echo "
                This script is UNSIGNED and may not be safe to run!
                (Maybe you modified the original script or perhaps
                you added an UNTRUSTED author's script/repository?)" | print_red #| center

    entertocontinue
  fi
}


autoupdatechecker() {
    # âš™ï¸ Number of days after which to check for updates
    local UPDATE_INTERVAL_DAYS=5

    local TMP_FILE="$localtempdirectory/update_timestamp.tmp"

    # Create the temporary directory if it doesn't exist
    mkdir -p "$localtempdirectory" &>/dev/null

    # Always get current date and time in seconds
    local CURRENT_EPOCH=$(date +%s)
    local CURRENT_DATE=$(date +%Y-%m-%d)

    local LAST_DATE=""
    local DIFF=0

    # Check if the .tmp file exists and contains a valid date
    if [ -f "$TMP_FILE" ]; then
        LAST_DATE=$(cat "$TMP_FILE" | tr -d '\r\n')  # Sanitize input

        # Check if LAST_DATE is a valid date
        if date -d "$LAST_DATE" +%s &>/dev/null; then
            local LAST_EPOCH=$(date -d "$LAST_DATE" +%s)
            DIFF=$(( (CURRENT_EPOCH - LAST_EPOCH) / 86400 ))
        else
            # Treat invalid date as expired (force update)
            echo "Warning: Invalid or corrupted date in timestamp file. Forcing update check." | center
            # Update the .tmp file with the current date
            echo "$CURRENT_DATE" > "$TMP_FILE"
            DIFF=$((UPDATE_INTERVAL_DAYS + 1))  # Force trigger
        fi
    else
        # No previous timestamp â€” treat as expired (first run)
        echo "No previous update timestamp found. Initializing..." | center
        # Update the .tmp file with the current date
        echo "$CURRENT_DATE" > "$TMP_FILE"
        DIFF=$((UPDATE_INTERVAL_DAYS + 1))  # Force trigger
    fi

    # Check if the required number of days has passed
    if [ "$DIFF" -ge "$UPDATE_INTERVAL_DAYS" ]; then
        echo "Updating signatures..." | center
        signatureupdate-force
        echo "Checking if $programname needs updates..." | center
        pullforupdates
        echo "Refreshing repositories..." | center
        refreshrepositories
        # âœ… Reset the timestamp to today after update
        echo "$CURRENT_DATE" > "$TMP_FILE"
    else
        echo "Update check skipped. Last check was $DIFF day(s) ago. Next check in $((UPDATE_INTERVAL_DAYS - DIFF)) day(s)." | center
    fi

    sleep 1

}


signatureupdate-force () {

    # Define directories and files
    local SIGNATURE_INSPECTION_POINT="$localtempdirectory/ghostAPT_signatures.sha256"
    local KEY_SHA256_LOC="$localtempdirectory/key.sha256"

    local REMOTE_FILE="https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/ghostAPT_signatures.sha256"
    local REMOTE_SIGNATURE="https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/key.sha256"

    local SIGNATUREUPDATEPATH="$localinstalldirectory/ghostAPT_signatures.sha256"

    # Create the temporary directory if it doesn't exist
    mkdir -p "$localtempdirectory" &>/dev/null

  if ! hash wget &>/dev/null; then
    echo "Error: wget not found/installed." | center
    return 1
  fi

  if ! hash sha256sum &>/dev/null; then
    echo "Error: sha256sum not found/installed." | center
    return 1
  fi

  if ! wget -qO- "$REMOTE_FILE" > "$SIGNATURE_INSPECTION_POINT"; then
    echo "Error: Failed to download remote file." | center
    return 1
  fi

  if ! wget -qO- "$REMOTE_SIGNATURE" > "$KEY_SHA256_LOC"; then
    echo "Error: Failed to download remote signature." | center
    return 1
  fi

  local REMOTE_CHECKSUM=$(cat "$KEY_SHA256_LOC")
  local LOCAL_CHECKSUM=$(sha256sum "$SIGNATURE_INSPECTION_POINT" | cut -d ' ' -f1)

  if [ "$REMOTE_CHECKSUM" != "$LOCAL_CHECKSUM" ]; then
    echo "
Error: SHA-256 verification failed.

Local checksum: $LOCAL_CHECKSUM

Remote checksum: $REMOTE_CHECKSUM." | center
    return 1
  fi

  # If the verification is successful, update the local file
  cat "$SIGNATURE_INSPECTION_POINT" >> "$SIGNATUREUPDATEPATH"

  echo "Signatures have been updated." | center
}

signaturerepair () {

    # Define directories and files
    local SIGNATURE_INSPECTION_POINT="$localtempdirectory/ghostAPT_signatures.sha256"
    local KEY_SHA256_LOC="$localtempdirectory/key.sha256"

    local REMOTE_FILE="https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/ghostAPT_signatures.sha256"
    local REMOTE_SIGNATURE="https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/key.sha256"

    local SIGNATUREUPDATEPATH="$localinstalldirectory/ghostAPT_signatures.sha256"

    # Create the temporary directory if it doesn't exist
    mkdir -p "$localtempdirectory" &>/dev/null

  if ! hash wget &>/dev/null; then
    echo "Error: wget not found/installed." | center
    return 1
  fi

  if ! hash sha256sum &>/dev/null; then
    echo "Error: sha256sum not found/installed." | center
    return 1
  fi

  if ! wget -qO- "$REMOTE_FILE" > "$SIGNATURE_INSPECTION_POINT"; then
    echo "Error: Failed to download remote file." | center
    return 1
  fi

  if ! wget -qO- "$REMOTE_SIGNATURE" > "$KEY_SHA256_LOC"; then
    echo "Error: Failed to download remote signature." | center
    return 1
  fi

  local REMOTE_CHECKSUM=$(cat "$KEY_SHA256_LOC")
  local LOCAL_CHECKSUM=$(sha256sum "$SIGNATURE_INSPECTION_POINT" | cut -d ' ' -f1)

  if [ "$REMOTE_CHECKSUM" != "$LOCAL_CHECKSUM" ]; then
    echo "Error: SHA-256 verification failed. Local checksum: $LOCAL_CHECKSUM, Remote checksum: $REMOTE_CHECKSUM." | center
    return 1
  fi

  # If the verification is successful, overwrite the local file
  cp "$SIGNATURE_INSPECTION_POINT" "$SIGNATUREUPDATEPATH"

  echo "Signatures have been flushed and repaired.

Trust for $programname Scripts has been defaulted." | center

}

checkforupdates-force () {

rm -rf "$localtempdirectory/update_flag.tmp" &>/dev/null

echo "
Checking if $programname and main repositories needs updates...
" | center

remote_file_loc="https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/ghostAPT.sh"

remote_beta_status=$(curl -L -s $remote_file_loc | grep -oP '(?<=version=")[^"]*' | awk '{if ($0 ~ /BETA/) {print "BETA"} else {print "Stable"}}')

remote_version=$(curl -L -s $remote_file_loc | grep -oP '(?<=version=")[^"]*')
local_version="$version"

if [[ $remote_version =~ ([0-9]+\.[0-9]+) ]]; then
  remote_version=${BASH_REMATCH[1]}
fi

if [[ $remote_version =~ BETA ]]; then
  remote_is_beta=true
else
  remote_is_beta=false
fi

if [[ $local_version =~ BETA ]]; then
  local_is_beta=true
else
  local_is_beta=false
fi

if [[ $remote_version > $local_version ]]; then
  echo "There's an update available!" | center

  #echo "$programname is currently: $local_version"
  echo ""
  echo "update flag: 1" > $localtempdirectory/update_flag.tmp
  echo "version: $remote_version" | tee -a "$localtempdirectory/update_flag.tmp" #&>/dev/null
  echo "stage: $remote_beta_status" | tee -a "$localtempdirectory/update_flag.tmp" #&>/dev/null

  needsupdates="1"
  update_flag

  echo "Update available for $programname. Do you want to update?" | center
select yn in "Yes" "No"; do
  case $yn in
    Yes )
      # update code here
      ghost_updater
      rm -rf "$localtempdirectory/update_flag.tmp" &>/dev/null
      update_flag
      echo "You must restart the program, exiting now." | center
      sleep 1
      exit;;
    No )
      echo "Update cancelled." | center
      sleep 1
      break;;
  esac
done

elif [[ $remote_version < $local_version ]]; then
  echo "$programname is up to date." | center
  #echo "$programname is up to date: $local_version"
  needsupdates="0"
  update_flag
else
  echo "Versions are the same" | center
  needsupdates="0"
  update_flag
fi

refreshrepositories

sleep 1

}

pullforupdates () {

#rm -rf "$localtempdirectory/update_flag.tmp" &>/dev/null

echo "
Checking if $programname needs updates...
" | center

remote_file_loc="https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/ghostAPT.sh"

remote_beta_status=$(curl -L -s $remote_file_loc | grep -oP '(?<=version=")[^"]*' | awk '{if ($0 ~ /BETA/) {print "BETA"} else {print "Stable"}}')

remote_version=$(curl -L -s $remote_file_loc | grep -oP '(?<=version=")[^"]*')
local_version="$version"

if [[ $remote_version =~ ([0-9]+\.[0-9]+) ]]; then
  remote_version=${BASH_REMATCH[1]}
fi

if [[ $remote_version =~ BETA ]]; then
  remote_is_beta=true
else
  remote_is_beta=false
fi

if [[ $local_version =~ BETA ]]; then
  local_is_beta=true
else
  local_is_beta=false
fi

if [[ $remote_version > $local_version ]]; then
  echo "There's an update available!" | center

  #echo "$programname is currently: $local_version"
  echo ""
  echo "update flag: 1" > $localtempdirectory/update_flag.tmp
  echo "version: $remote_version" | tee -a "$localtempdirectory/update_flag.tmp" | center #&>/dev/null
  echo "stage: $remote_beta_status" | tee -a "$localtempdirectory/update_flag.tmp" | center #&>/dev/null

  needsupdates="1"
  update_flag

elif [[ $remote_version < $local_version ]]; then
  echo "$programname is up to date." | center
  #echo "$programname is up to date: $local_version"
  needsupdates="0"
  update_flag
else
  echo "Versions are the same" | center
  needsupdates="0"
  update_flag
fi

}

updates-menuitem () {

if [ "$needsupdates" == 1 ]; then
    updatesmenuitem="*** Update $programname ***"
    else
    updatesmenuitem="Check $programname for updates"
    fi

}

update_flag () {

if [ -f "$localtempdirectory/update_flag.tmp" ]; then
  updateflag=$(cat "$localtempdirectory/update_flag.tmp" | grep 'update flag: ' | awk '{ print $3 }')
  # rest of your code here
fi


if [ "$updateflag" == 1 ]; then
  needsupdates="1"
  remote_version=$(cat "$localtempdirectory/update_flag.tmp" | grep 'version: ' | tail -n '1' | awk '{ print $2 }')
  remote_beta_status=$(cat "$localtempdirectory/update_flag.tmp" | grep 'stage: ' | tail -n '1' | awk '{ print $2 }')
else
  needsupdates="0"
fi

}

# Define the ghost_updater function
ghost_updater() {

  # Define the log file
  log_file="$localtempdirectory/$programname-update.log"

  # Define the array of remote files
  remote_files=(
    "https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/ghostAPT.sh"
    "https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/data.lib"
    "https://github.com/jcore92/ghostAPT/raw/refs/heads/$ghbranch/interface.lib"
    # Add more files as needed
  )

  # Check if the needsupdates variable is set to 1
  if [ "$needsupdates" == "1" ]; then
    # Download the remote files
    echo "Performing update...please wait" | center
    # Clear the old log
    rm -rf "$localtempdirectory/$log_file" &>/dev/null
    date | tee -a $log_file
    echo "Downloading remote files..." >> "$log_file"
    for file in "${remote_files[@]}"; do
      if curl -L -s "$file" > "$localinstalldirectory/$(basename "$file")"; then
        echo "Remote file $file downloaded successfully." >> "$log_file"
      else
        echo "Error downloading remote file $file." >> "$log_file"
      fi
    done
    echo "Remote files downloaded successfully." >> "$log_file"
    echo "Refreshing repositories..."
    refreshrepositories
    rm -rf "$localtempdirectory/update_flag.tmp" &>/dev/null
    ghostAPT installicons
    echo "
You must restart the program, exiting now.
" | center
    sleep 2
    exit
  else
    date | tee -a $log_file
    echo "No updates available." >> "$log_file"
  fi

}

check_if_secure_format () {
    divider
    echo "
Checking if script format is secure...
"
    local required_lines=(
        "1:#!/bin/bash"
        "2:source \"\$HOME/ghostAPT/data.lib\""
        "3:source \"\$HOME/ghostAPT/interface.lib\""
        "4:code-goes-below"
    )

    if [ ! -f "$full_path" ]; then
        echo "Error: .ghost file not found."
        entertocontinue
        return 1
    fi

    local line_number=1
    while IFS= read -r line; do
        for required in "${required_lines[@]}"; do
            IFS=':' read -r req_line_number req_line_content <<< "$required"
            if [ "$line_number" -eq "$req_line_number" ]; then
                echo "Checking line $line_number for: $req_line_content"
                scriptformatnotice="Secure"
                #echo "Checking line $line_number: '$line' vs '$req_line_content'"
                if [ "$line" != "$req_line_content" ]; then
                    scriptformatnotice="$(echo "Insecure" | print_red)"
                    echo "
Error: Required line not found on line $req_line_number in .ghost file.
" | print_red #$req_line_content
                    echo "Line $req_line_number in Script:
'$line'" | print_red
                    echo "
                    Script Format: $scriptformatnotice" | center
                    divider
                    echo "
This .ghost script is not properly formatted.
For your safety, we cannot open the file until it is properly formatted.

You must put this header at the very top of your script or it won't work or be considered secure:

#!/bin/bash
source \"\$HOME/ghostAPT/data.lib\"
source \"\$HOME/ghostAPT/interface.lib\"
code-goes-below"
                    divider
                    cat "$full_path"
                    scriptformat="0"
                    return 1
                    else
                    scriptformat="1"
                fi
            fi
        done
        ((line_number++))
    done < "$full_path"
    echo "

Script Format: $scriptformatnotice" | center
}

directory_menu() {
  local dir="$localinstalldirectory"
  local menu=()

  # Build list of subdirectories
  for sub_dir in "$dir"/*; do
    if [ -d "$sub_dir" ]; then
      menu+=("${sub_dir##*/}")  # Extract dir name only
    fi
  done

  # Add "Back" option
  menu+=("Back")

  # If no directories found
  if [ ${#menu[@]} -eq 1 ]; then
    echo "No directories found."
    read -p "Press Enter to continue..."
    return
  fi
  echo "Ghost Scripts -> Categories"
  # Use cursor menu for selection
  local selected
  basic_cursor_menu " " selected "${menu[@]}"

  # Process selection
  if [ "$selected" == "Back" ]; then
    softwaremenusticky="0"
    break 2
  else
    scriptmenusticky="1"
    while [ "$scriptmenusticky" == "1" ]; do
      clear && printf '\e[3J'
      header
      installationstatus
      echo "Select a $programname Script to run:"
      echo
      display_ghost_files "$selected"
    done
  fi
}

display_ghost_files() {
  local dir="$1"

  # Arrays to hold .ghost files, names, and mapping
  local ghost_files=()
  local ghost_file_names=()
  local script_display_names=()
  local script_map=()

  # Build list of .ghost files
  for file in "$localinstalldirectory/$dir/"*.ghost; do
    if [[ -f "$file" ]]; then
      ghost_files+=("$file")
      local file_name=$(basename "$file" .ghost)
      ghost_file_names+=("$file_name")
      script_display_names+=("$file_name")
      script_map+=("$file_name:$file")
    fi
  done

  # Add special options
  ghost_file_names+=("Edit Scripts" "Back")

  # If no scripts found
  if [ ${#ghost_file_names[@]} -eq 2 ]; then
    echo "No .ghost scripts found."
    entertocontinue
    return
  fi

  # Main loop â€” this will re-show the menu after every action
  while true; do
    # Clear screen and redraw header + prompt
    clear && printf '\e[3J'
    header
    installationstatus
    echo "Ghost Scripts -> Categories -> $selected"

    # Show cursor menu
    local selection
    basic_cursor_menu " " selection "${ghost_file_names[@]}"

    case "$selection" in
      "Back")
        scriptmenusticky="0"
        break
        ;;

      "Edit Scripts")
        # Build edit menu
        local edit_options=("${script_display_names[@]}" "Back")
        local edit_selection

        # Clear and show edit header
        clear && printf '\e[3J'
        header
        installationstatus
        echo "Select a Ghost Script to edit:"
        basic_cursor_menu " " edit_selection "${edit_options[@]}"

        if [ "$edit_selection" == "Back" ]; then
          continue  # Return to main menu
        fi

        # Resolve path
        local full_path=""
        for entry in "${script_map[@]}"; do
          IFS=':' read -r name path <<< "$entry"
          if [[ "$name" == "$edit_selection" ]]; then
            full_path="$path"
            break
          fi
        done

        if [[ -z "$full_path" ]]; then
          echo ""
          echo "Error: Could not find the full path for $edit_selection." | center
          echo ""
          entertocontinue
          continue
        fi

        echo ""
        echo "Opening $edit_selection in the Editor..." | center
        echo ""
        local checktrust=$(sha256sum "$full_path" | cut -d ' ' -f1)

        # Launch editor
        konsole -e "nano \"$full_path\""
        local updatetrust=$(sha256sum "$full_path" | cut -d ' ' -f1)

        # Update signature if changed
        if [[ "$updatetrust" != "$checktrust" ]]; then
          echo "$updatetrust $USER ($edit_selection)" >> "$localinstalldirectory/ghostAPT_signatures.sha256"
          echo ""
          echo "Updated $edit_selection's trust with new signature." | center
          echo ""
          divider
          entertocontinue
        fi

        # Re-render menu after edit
        continue
        ;;

      *)
        # Run selected script
        local full_path=""
        for entry in "${script_map[@]}"; do
          IFS=':' read -r name path <<< "$entry"
          if [[ "$name" == "$selection" ]]; then
            full_path="$path"
            break
          fi
        done

        if [[ -z "$full_path" ]]; then
          echo ""
          echo "Error: Could not find the full path for $selection." | center
          echo ""
          entertocontinue
          continue
        fi

          check_if_secure_format
        if [ "$scriptformat" == "1" ]; then
          echo ""
          echo "Running $selection..." | center
          echo ""
          konsole -e "bash \"$full_path\"" &
        fi

        divider
        entertocontinue | center

        # Re-render the menu after running the script
        continue
        ;;
    esac
  done
}

code-goes-below (){

localtempdirectory="/tmp/ghostAPT"
localinstalldirectory="$HOME/ghostAPT"

ghbranch="main"

# Scrape scripts for infos
SCRIPT_NAME=$(basename "$0")
DIR="$(dirname "$(realpath "$0")")"

scriptname="$(cat "$DIR/$SCRIPT_NAME" | grep "scriptname" | awk -F= '{gsub(/"/, "", $2); print $2}')"

author="$(cat "$DIR/$SCRIPT_NAME" | grep "author" | awk -F= '{gsub(/"/, "", $2); print $2}')"

version="$(cat "$DIR/$SCRIPT_NAME" | grep "version" | awk -F= '{gsub(/"/, "", $2); print $2}')"

#builddate="$(cat "$DIR/$SCRIPT_NAME" | grep "builddate" | awk -F= '{gsub(/"/, "", $2); print $2}')"

header-script

echo "" ; echo "Script Name: $scriptname" | head -n 1 | center ; echo "" ; echo "Author: $author" | head -n 1 | center ; echo "" ; echo "Version $version" | head -n 1 | center ; echo ""


signature | center

divider

# cat the script first
cat "$0"

divider

echo "

Please review the script before you run it.

If you do not wish to run it, close this window or press CTL+C to exit.
" | center

divider

entertocontinue

}

code-goes-above-^ (){

echo "

Script has finished running.
" | center

entertocontinue

exit

}

###############################################################
#
#   3. Terminal Menus
#
################################################################

# Installer Menu
installermenu (){

    hierarchy="1"

    while [ "$hierarchy" == "1" ]; do
    if [ "$hierarchy" == "1" ]; then clear && printf '\e[3J' ; header-installer ; installationstatus

    if [ "$installationstatus" == "$whichverinstalled is Installed" ]; then

        # Usage:
        choices=("Uninstall $programname" "Exit $programname $installername")
        basic_cursor_menu "Please make a selection below:" selected "${choices[@]}"
        echo "
Selected: $selected
"

            if [ "$selected" == "Uninstall $programname" ]; then echo "Are you sure you want to uninstall $programname?
"
                # Usage:
                choices=("Yes, uninstall $programname" "No, cancel uninstallation")
                basic_cursor_menu "Please make a selection below:" selected "${choices[@]}"
                echo "
Selected: $selected
"

                if [ "$selected" == "Yes, uninstall $programname" ]; then echo "Uninstalling $programname..." ; uninstaller | center ; exit
                fi

                if [ "$selected" == "No, cancel uninstallation" ]; then echo "Uninstallation cancelled." ; sleep 1 ; exit
                fi

            fi

            if [ "$selected" == "Exit $programname $installername" ]; then echo "Exiting $programname..." ; sleep 1 ; exit
            fi

        else

        # Usage:
        choices=("Install $programname" "Exit $programname $installername")
        basic_cursor_menu "Please make a selection below:" selected "${choices[@]}"
        echo "
Selected $selected
"

        if [ "$selected" == "Install $programname" ]; then echo "Proceeding to install $programname..."
            installation #| center
            konsole -e "$localinstalldirectory/ghostAPT.sh run" &
            exit
            #hierarchy="1"
        fi

        if [ "$selected" == "Exit $programname $installername" ]; then echo "Exiting $programname..." ; sleep 1 ; clear ; exit
        fi

    fi
    fi
    done

}

runghost (){

    # Installation and temp directory
    localtempdirectory="/tmp/ghostAPT"
    localinstalldirectory="$HOME/ghostAPT"

    hierarchy="1"

    #update_flag
    #updates-menuitem

    #categories=("$USER's Script Library" "Copy System Info To Clipboard" "$updatesmenuitem" "Signature Management" "Exit $programname")

    while [ "$hierarchy" == "1" ]; do

    update_flag
    updates-menuitem

    if [ "$hierarchy" == "1" ]; then clear && printf '\e[3J' ; header ; installationstatus ; update_flag ; updates-menuitem

        # Usage:
        choices=("View Ghost Scripts" "View System Info" "$updatesmenuitem" "Signature Management" "About $programname" "Exit $programname")
        echo "Please make a selection below:"
        basic_cursor_menu " " selected "${choices[@]}"
        #echo "
#Selected: $selected
#"

    if [ "$selected" == "View Ghost Scripts" ]; then

    softwaremenusticky="1"
    while [ "$softwaremenusticky" == "1" ]; do
    if [ "$softwaremenusticky" == "1" ]; then clear && printf '\e[3J' ; header ; installationstatus
    directory_menu #find_software_menu
    fi
    done
    #hierarchy="1"

    fi

    if [ "$selected" == "View System Info" ]; then

    clear ; header ; installationstatus ; systeminfo ; sysinfo-copyall ; sleep .7
    clear ; header ; installationstatus ; systeminfo ; sysinfo-all
    echo "System Information has been copied to your clipboard." | center
    entertocontinue | center
    hidepublicipprobe
    #hierarchy="2"

    fi

    if [ "$selected" == "$updatesmenuitem" ]; then

    if [ "$needsupdates" == 1 ]; then
    updatesmenuitem="Update $programname"
    ghost_updater
    fi

    if [ "$needsupdates" == 0 ]; then
    updatesmenuitem="Check $programname for updates"
    checkforupdates-force
    update_flag
    fi

    #hierarchy="1"

    fi

    if [ "$selected" == "Signature Management" ]; then

        clear ; header ; installationstatus

        # Usage:
        choices=("Update Signatures" "Repair Signatures" "Trust All Installed Signatures" "Back")
        echo "Please make a selection below:"
        basic_cursor_menu " " selected "${choices[@]}"

        if [ "$selected" == "Update Signatures" ]; then
        signatureupdate-force
        entertocontinue | center
        fi

        if [ "$selected" == "Repair Signatures" ]; then
        signaturerepair
        entertocontinue | center
        fi

        if [ "$selected" == "Trust All Installed Signatures" ]; then
        echo "Are you sure you want to trust all installed $programname scripts?"
                select choice in "Yes, trust installed $programname scripts" "No, cancel"; do
                    case $choice in
                        "Yes, trust installed $programname scripts")
                            trustinstalledscripts $localinstalldirectory
                            break;;
                        "No, cancel")
                            echo "Operation cancelled."
                            break;;
                    esac
                done
        fi

        if [ "$selected" == "Back" ]; then
        echo ""
        fi

    fi

    if [ "$selected" == "About $programname" ]; then

    echo "



"
    credits
    echo "
"
    entertocontinue | center

    fi

    if [ "$selected" == "Exit $programname" ]; then

    clear
    hierarchy="0"

    fi


    fi
    done

}
